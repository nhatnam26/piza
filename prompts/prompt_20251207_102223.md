**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `devnet`
- **Package ID:** `0x6b59a9423c6aa80f8c6e7e6ec0fe93f38168ce412254880ae59616d06ac275d4`
- **Module Name:** `pizza`
- **Available Methods:**

  * `cook` (constant: `COOK`)
  * `get_flag` (constant: `GET_FLAG`)

---

# **Move Contract: `contract/pizza_box/sources/pizza_box.move`**

```move
module pizza_box::pizza {
use std::bcs;
use iota::object;
use iota::transfer;
use iota::tx_context;
use iota::object::UID;
public struct Pizza has store {
olive_oils: u16,
yeast: u16,
flour: u16,
water: u16,
salt: u16,
tomato_sauce: u16,
cheese: u16,
pineapple: u16,
}
public struct PizzaBox has key, store {
id: UID,
pizza: Pizza,
}
public struct Flag has key, store {
id: UID,
user: address
}
const EMamaMiaNonBene: u64 = 0;
#[allow(lint(self_transfer))]
public entry fun cook(
olive_oils: u16,
yeast: u16,
flour: u16,
water: u16,
salt: u16,
tomato_sauce: u16,
cheese: u16,
pineapple: u16,
ctx: &mut tx_context::TxContext
) {
let sender = tx_context::sender(ctx);
let p = Pizza {
olive_oils,
yeast,
flour,
water,
salt,
tomato_sauce,
cheese,
pineapple,
};
transfer::public_transfer(
PizzaBox { id: object::new(ctx), pizza: p },
sender
);
}
#[allow(lint(self_transfer))]
public entry fun get_flag(
pizzabox: &PizzaBox,
ctx: &mut tx_context::TxContext
) {
assert!(
bcs::to_bytes(&pizzabox.pizza) ==
x"0a000300620272011200c800b4000000",
EMamaMiaNonBene
);
let sender = tx_context::sender(ctx);
transfer::public_transfer(
Flag {
id: object::new(ctx),
user: sender
},
sender
);
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
"use client";

/**
 * ============================================================================
 * IOTA CONTRACT INTEGRATION HOOK
 * ============================================================================
 *
 * This hook contains ALL the contract interaction logic.
 *
 * To customize your dApp, modify the configuration section below.
 *
 * ============================================================================
 */

import { useState } from "react";
import {
  useCurrentAccount,
  useIotaClient,
  useSignAndExecuteTransaction,
  useIotaClientQuery,
} from "@iota/dapp-kit";
import { Transaction } from "@iota/iota-sdk/transactions";
import { useNetworkVariable } from "@/lib/config";
import type { IotaObjectData } from "@iota/iota-sdk/client";

// ============================================================================
// CONTRACT CONFIGURATION
// ============================================================================
// Change these values to match your Move contract

export const CONTRACT_MODULE = "pizza"; // Your Move module name
export const CONTRACT_METHODS = {
  COOK: "cook",
  GET_FLAG: "get_flag",
} as const;

// ============================================================================
// DATA EXTRACTION
// ============================================================================
// Modify this to extract data from your contract's object structure

interface PizzaData {
  oliveOils: number;
  yeast: number;
  flour: number;
  water: number;
  salt: number;
  tomatoSauce: number;
  cheese: number;
  pineapple: number;
}

function getPizzaBoxFields(data: IotaObjectData): PizzaData | null {
  if (data.content?.dataType !== "moveObject") {
    console.log("Data is not a moveObject:", data.content?.dataType);
    return null;
  }

  const fields = data.content.fields as Record<string, unknown>;
  if (!fields || !fields.pizza) {
    console.log("No pizza fields found in object data");
    return null;
  }

  // Log the actual structure for debugging
  console.log("PizzaBox fields structure:", JSON.stringify(fields, null, 2));

  const pizza = fields.pizza as Record<string, unknown>;

  try {
    return {
      oliveOils: parseInt(String(pizza.olive_oils), 10),
      yeast: parseInt(String(pizza.yeast), 10),
      flour: parseInt(String(pizza.flour), 10),
      water: parseInt(String(pizza.water), 10),
      salt: parseInt(String(pizza.salt), 10),
      tomatoSauce: parseInt(String(pizza.tomato_sauce), 10),
      cheese: parseInt(String(pizza.cheese), 10),
      pineapple: parseInt(String(pizza.pineapple), 10),
    };
  } catch (error) {
    console.error("Error parsing pizza fields:", error);
    return null;
  }
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export interface ContractData {
  oliveOils: number;
  yeast: number;
  flour: number;
  water: number;
  salt: number;
  tomatoSauce: number;
  cheese: number;
  pineapple: number;
}

export interface ContractState {
  isLoading: boolean;
  isPending: boolean;
  isConfirming: boolean;
  isConfirmed: boolean;
  hash: string | undefined;
  error: Error | null;
}

export interface ContractActions {
  cookPizza: (
    oliveOils: number,
    yeast: number,
    flour: number,
    water: number,
    salt: number,
    tomatoSauce: number,
    cheese: number,
    pineapple: number
  ) => Promise<void>;
  getFlag: () => Promise<void>;
  clearObject: () => void;
}

export const useContract = () => {
  const currentAccount = useCurrentAccount();
  const address = currentAccount?.address;
  const packageId = useNetworkVariable("packageId");
  const iotaClient = useIotaClient();
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction();
  const [pizzaBoxId, setPizzaBoxId] = useState<string | null>(() => {
    if (typeof window !== "undefined" && currentAccount?.address) {
      return localStorage.getItem(`pizzaBoxId_${currentAccount.address}`);
    }
    return null;
  });
  const [flagId, setFlagId] = useState<string | null>(() => {
    if (typeof window !== "undefined" && currentAccount?.address) {
      return localStorage.getItem(`flagId_${currentAccount.address}`);
    }
    return null;
  });
  const [isLoading, setIsLoading] = useState(false);
  const [hash, setHash] = useState<string | undefined>();
  const [transactionError, setTransactionError] = useState<Error | null>(null);

  // Fetch pizza box data
  const {
    data,
    isPending: isFetching,
    error: queryError,
    refetch,
  } = useIotaClientQuery(
    "getObject",
    {
      id: pizzaBoxId!,
      options: { showContent: true, showOwner: true },
    },
    {
      enabled: !!pizzaBoxId,
    }
  );

  // Extract fields
  const fields = data?.data ? getPizzaBoxFields(data.data) : null;

  // Check if object exists but data extraction failed
  const objectExists = !!data?.data;
  const hasValidData = !!fields;

  // Cook Pizza
  const cookPizza = async (
    oliveOils: number,
    yeast: number,
    flour: number,
    water: number,
    salt: number,
    tomatoSauce: number,
    cheese: number,
    pineapple: number
  ) => {
    if (!packageId) return;

    try {
      setTransactionError(null);
      setHash(undefined);
      const tx = new Transaction();
      tx.moveCall({
        arguments: [
          tx.pure.u16(oliveOils),
          tx.pure.u16(yeast),
          tx.pure.u16(flour),
          tx.pure.u16(water),
          tx.pure.u16(salt),
          tx.pure.u16(tomatoSauce),
          tx.pure.u16(cheese),
          tx.pure.u16(pineapple),
        ],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.COOK}`,
      });

      signAndExecute(
        { transaction: tx as never },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest);
            setIsLoading(true);
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              });
              const newPizzaBoxId = effects?.created?.[0]?.reference?.objectId;
              if (newPizzaBoxId) {
                setPizzaBoxId(newPizzaBoxId);
                if (typeof window !== "undefined" && address) {
                  localStorage.setItem(`pizzaBoxId_${address}`, newPizzaBoxId);
                }
                await refetch();
                setIsLoading(false);
              } else {
                setIsLoading(false);
                console.warn("No pizza box ID found in transaction effects");
              }
            } catch (waitError) {
              console.error("Error waiting for transaction:", waitError);
              setIsLoading(false);
            }
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err));
            setTransactionError(error);
            console.error("Error:", err);
          },
        }
      );
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setTransactionError(error);
      console.error("Error cooking pizza:", err);
    }
  };

  // Get Flag
  const getFlag = async () => {
    if (!pizzaBoxId || !packageId) return;

    try {
      setTransactionError(null);
      const tx = new Transaction();
      tx.moveCall({
        arguments: [tx.object(pizzaBoxId)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.GET_FLAG}`,
      });

      signAndExecute(
        { transaction: tx as never },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest);
            setIsLoading(true);
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              });
              const newFlagId = effects?.created?.[0]?.reference?.objectId;
              if (newFlagId) {
                setFlagId(newFlagId);
                if (typeof window !== "undefined" && address) {
                  localStorage.setItem(`flagId_${address}`, newFlagId);
                }
                setIsLoading(false);
              } else {
                setIsLoading(false);
                console.warn("No flag ID found in transaction effects");
              }
            } catch (waitError) {
              console.error("Error waiting for transaction:", waitError);
              setIsLoading(false);
            }
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err));
            setTransactionError(error);
            console.error("Error:", err);
          },
        }
      );
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setTransactionError(error);
      console.error("Error getting flag:", err);
    }
  };

  const contractData: ContractData | null = fields;

  const clearObject = () => {
    setPizzaBoxId(null);
    setFlagId(null);
    setTransactionError(null);
    if (typeof window !== "undefined" && address) {
      localStorage.removeItem(`pizzaBoxId_${address}`);
      localStorage.removeItem(`flagId_${address}`);
    }
  };

  const actions: ContractActions = {
    cookPizza,
    getFlag,
    clearObject,
  };

  const contractState: ContractState = {
    isLoading: isLoading,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  };

  return {
    data: contractData,
    actions,
    state: contractState,
    pizzaBoxId,
    flagId,
    objectExists,
    hasValidData,
    isFetching,
  };
};

```

---

# File 2: `components/sample.tsx`

```tsx
"use client";

/**
 * ============================================================================
 * PIZZA BOX DAPP INTEGRATION COMPONENT
 * ============================================================================
 *
 * This component allows users to cook pizzas and get flags when they cook
 * the perfect pizza with the right ingredients.
 *
 * All the contract logic is in hooks/useContract.ts
 *
 * ============================================================================
 */

import { useCurrentAccount } from "@iota/dapp-kit";
import { useContract } from "@/hooks/useContract";
import { Button, Container, Heading, Text, TextField } from "@radix-ui/themes";
import ClipLoader from "react-spinners/ClipLoader";
import { useState } from "react";

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount();
  const { data, actions, state, pizzaBoxId, flagId } = useContract();

  const [ingredients, setIngredients] = useState({
    oliveOils: "10",
    yeast: "3",
    flour: "98",
    water: "114",
    salt: "18",
    tomatoSauce: "200",
    cheese: "180",
    pineapple: "0",
  });

  const isConnected = !!currentAccount;

  const handleIngredientChange = (field: string, value: string) => {
    setIngredients((prev) => ({ ...prev, [field]: value }));
  };

  if (!isConnected) {
    return (
      <div
        style={{
          minHeight: "100vh",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          padding: "1rem",
        }}
      >
        <div style={{ maxWidth: "500px", width: "100%" }}>
          <Heading size="6" style={{ marginBottom: "1rem" }}>
            üçï Pizza Box dApp
          </Heading>
          <Text>Please connect your wallet to cook pizzas!</Text>
        </div>
      </div>
    );
  }

  return (
    <div
      style={{
        minHeight: "100vh",
        padding: "1rem",
        background: "var(--gray-a2)",
      }}
    >
      <Container style={{ maxWidth: "800px", margin: "0 auto" }}>
        <Heading size="6" style={{ marginBottom: "2rem" }}>
          üçï Pizza Box dApp
        </Heading>

        {/* Flag Status */}
        {flagId && (
          <div
            style={{
              marginBottom: "1rem",
              padding: "1.5rem",
              background: "var(--green-a3)",
              borderRadius: "8px",
              border: "2px solid var(--green-7)",
            }}
          >
            <Heading size="4" style={{ marginBottom: "0.5rem" }}>
              üéâ Congratulations! Flag Captured!
            </Heading>
            <Text
              style={{
                color: "var(--green-11)",
                display: "block",
                marginBottom: "0.5rem",
              }}
            >
              You&apos;ve cooked the perfect pizza and earned your flag!
            </Text>
            <Text
              size="1"
              style={{
                color: "var(--gray-a11)",
                display: "block",
                fontFamily: "monospace",
                wordBreak: "break-all",
              }}
            >
              Flag ID: {flagId}
            </Text>
          </div>
        )}

        {/* Pizza Box Status */}
        {pizzaBoxId && data && (
          <div
            style={{
              marginBottom: "1rem",
              padding: "1rem",
              background: "var(--gray-a3)",
              borderRadius: "8px",
            }}
          >
            <Text
              size="2"
              style={{
                display: "block",
                marginBottom: "0.5rem",
                fontWeight: "bold",
              }}
            >
              Your Pizza Box üì¶
            </Text>
            <div
              style={{
                display: "grid",
                gridTemplateColumns: "1fr 1fr",
                gap: "0.5rem",
                marginBottom: "1rem",
              }}
            >
              <Text size="2">Olive Oils: {data.oliveOils}</Text>
              <Text size="2">Yeast: {data.yeast}</Text>
              <Text size="2">Flour: {data.flour}</Text>
              <Text size="2">Water: {data.water}</Text>
              <Text size="2">Salt: {data.salt}</Text>
              <Text size="2">Tomato Sauce: {data.tomatoSauce}</Text>
              <Text size="2">Cheese: {data.cheese}</Text>
              <Text size="2">Pineapple: {data.pineapple}</Text>
            </div>
            <Text
              size="1"
              style={{
                color: "var(--gray-a11)",
                display: "block",
                fontFamily: "monospace",
                wordBreak: "break-all",
              }}
            >
              PizzaBox ID: {pizzaBoxId}
            </Text>

            {!flagId && (
              <Button
                size="2"
                style={{ marginTop: "1rem" }}
                onClick={actions.getFlag}
                disabled={state.isLoading || state.isPending}
              >
                {state.isLoading || state.isPending ? (
                  <>
                    <ClipLoader size={14} style={{ marginRight: "8px" }} />
                    Checking...
                  </>
                ) : (
                  "üö© Get Flag"
                )}
              </Button>
            )}
          </div>
        )}

        {/* Cook Pizza Form */}
        <div
          style={{
            padding: "1.5rem",
            background: "var(--gray-a3)",
            borderRadius: "8px",
            marginBottom: "1rem",
          }}
        >
          <Heading size="4" style={{ marginBottom: "1rem" }}>
            Cook a Pizza üë®‚Äçüç≥
          </Heading>

          <div
            style={{
              display: "grid",
              gridTemplateColumns: "1fr 1fr",
              gap: "1rem",
              marginBottom: "1rem",
            }}
          >
            <div>
              <Text
                size="2"
                style={{ display: "block", marginBottom: "0.3rem" }}
              >
                Olive Oils
              </Text>
              <TextField.Root
                value={ingredients.oliveOils}
                onChange={(e) =>
                  handleIngredientChange("oliveOils", e.target.value)
                }
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div>
              <Text
                size="2"
                style={{ display: "block", marginBottom: "0.3rem" }}
              >
                Yeast
              </Text>
              <TextField.Root
                value={ingredients.yeast}
                onChange={(e) =>
                  handleIngredientChange("yeast", e.target.value)
                }
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div>
              <Text
                size="2"
                style={{ display: "block", marginBottom: "0.3rem" }}
              >
                Flour
              </Text>
              <TextField.Root
                value={ingredients.flour}
                onChange={(e) =>
                  handleIngredientChange("flour", e.target.value)
                }
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div>
              <Text
                size="2"
                style={{ display: "block", marginBottom: "0.3rem" }}
              >
                Water
              </Text>
              <TextField.Root
                value={ingredients.water}
                onChange={(e) =>
                  handleIngredientChange("water", e.target.value)
                }
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div>
              <Text
                size="2"
                style={{ display: "block", marginBottom: "0.3rem" }}
              >
                Salt
              </Text>
              <TextField.Root
                value={ingredients.salt}
                onChange={(e) => handleIngredientChange("salt", e.target.value)}
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div>
              <Text
                size="2"
                style={{ display: "block", marginBottom: "0.3rem" }}
              >
                Tomato Sauce
              </Text>
              <TextField.Root
                value={ingredients.tomatoSauce}
                onChange={(e) =>
                  handleIngredientChange("tomatoSauce", e.target.value)
                }
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div>
              <Text
                size="2"
                style={{ display: "block", marginBottom: "0.3rem" }}
              >
                Cheese
              </Text>
              <TextField.Root
                value={ingredients.cheese}
                onChange={(e) =>
                  handleIngredientChange("cheese", e.target.value)
                }
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div>
              <Text
                size="2"
                style={{ display: "block", marginBottom: "0.3rem" }}
              >
                Pineapple üçç
              </Text>
              <TextField.Root
                value={ingredients.pineapple}
                onChange={(e) =>
                  handleIngredientChange("pineapple", e.target.value)
                }
                type="number"
                min="0"
                max="65535"
              />
            </div>
          </div>

          <Button
            size="3"
            onClick={() =>
              actions.cookPizza(
                parseInt(ingredients.oliveOils),
                parseInt(ingredients.yeast),
                parseInt(ingredients.flour),
                parseInt(ingredients.water),
                parseInt(ingredients.salt),
                parseInt(ingredients.tomatoSauce),
                parseInt(ingredients.cheese),
                parseInt(ingredients.pineapple)
              )
            }
            disabled={state.isPending || state.isLoading}
          >
            {state.isLoading ? (
              <>
                <ClipLoader size={16} style={{ marginRight: "8px" }} />
                Cooking...
              </>
            ) : (
              "üçï Cook Pizza"
            )}
          </Button>
        </div>

        {/* Transaction Status */}
        {state.hash && (
          <div
            style={{
              marginTop: "1rem",
              padding: "1rem",
              background: "var(--gray-a3)",
              borderRadius: "8px",
            }}
          >
            <Text size="1" style={{ display: "block", marginBottom: "0.5rem" }}>
              Transaction Hash
            </Text>
            <Text
              size="2"
              style={{ fontFamily: "monospace", wordBreak: "break-all" }}
            >
              {state.hash}
            </Text>
            {state.isConfirmed && (
              <Text
                size="2"
                style={{
                  color: "green",
                  marginTop: "0.5rem",
                  display: "block",
                }}
              >
                ‚úÖ Transaction confirmed!
              </Text>
            )}
          </div>
        )}

        {/* Error Display */}
        {state.error && (
          <div
            style={{
              marginTop: "1rem",
              padding: "1rem",
              background: "var(--red-a3)",
              borderRadius: "8px",
            }}
          >
            <Text style={{ color: "var(--red-11)" }}>
              Error: {(state.error as Error)?.message || String(state.error)}
            </Text>
          </div>
        )}
      </Container>
    </div>
  );
};

export default SampleIntegration;

```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0x6b59a9423c6aa80f8c6e7e6ec0fe93f38168ce412254880ae59616d06ac275d4` and Module: `pizza`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
